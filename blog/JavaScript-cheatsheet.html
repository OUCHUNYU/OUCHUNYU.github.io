<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" type="text/css" href="../stylesheets/blog_template.css">
  <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">

  <title>Blog|Chunyu Ou</title>
  <style type="text/css">
    em {
      color: red;
      font-size: 1.5em;
      font-family: courier;
    }

    #bottom-nav a:hover {
      text-decoration: none;
    }

  </style>
</head>
<body>
 <div id="wrapper">
   <header>
    <div id="header-title">
      <a href="../index.html">Chunyu Ou</a>
    </div>
    <nav id="main-nav">
      <a href="../index.html">Home</a>
      <a href="../project.html">Project</a>
      <a href="../about.html">About</a>
    </nav>

    <div id="container">
      <ul>
        <li><a href="https://github.com/OUCHUNYU" target="_blank"><i class="fa fa-github fa-3x"></i></a></li>
        <li><a href="https://twitter.com/OUCHUNYU" target="_blank"><i class="fa fa-twitter fa-3x"></i>
        </a></li>
        <li><a href="https://www.facebook.com/chunyu.ou.52" target="_blank"><i class="fa fa-facebook-official fa-3x"></i></a></li>
      </ul>
    </div>
   </header>

   <main id="main-article">
    <p id="post-date">Created on: March 12, 2016</p>
    <hr>
    <h2>Learning With Eloquent JavaScript</h2>
    <p>I have been learning JavaScript for a couple of weeks with book Eloquent JavaScript, and feel this language is pretty insteresting. Here i list some of the knowledge i have found useful so far, i will keep updating this sheet untill the finish of the book.</p>
    <h3>Function(Chapter 3)</h3>
    <p>
      <strong>return</strong>: Returns the expression following this statement and pass the value the expression evaluates to the calling method. If there is nothing for return, this will cause the function to return undefined.<br>
      <strong>local variables</strong>: Local variables are local to a caller function, only variables defined within a function body and parameters of a funciton are local.<br>
      <strong>global variables</strong>: defined anywhere outside a function body, they are visible thruough out the program accessible with in functions.<br>
      <strong>Only functions create new scopes.</strong><br>
      <strong>Note, don't nest a function definition inside a if or loop block</strong><br>
      <strong>When calling a function, if the function takes 2 arguments and we supply it 3, the third one is discared. If we supply less than 2, the second argument will be auto assgined to undefined</strong><br>
      <strong>function recursion is about 10 times slower than a cheap loop call</strong><br>
    </p>
    <h3>Objects And Arrays(Chapter 4)</h3>
      In JavaScript all methods are refered to properties of an object, we have two ways to get access a property of an object. First using dot notaion, with the property name, and second one we can use brackets and property name with double quotation marks.<br>

      object: objects are arbitrary collections of properties. One way to create a object is by using a brace notation.<br>

      strings: we can add properties to an object but not to a string, if we added, nothing going to happen but this property will return only undefined. It only response to buildin properties like toUpperCase, length etc. <strong> Values of type like string, number, boolean are not objects. </strong><br>

      Arguments passed to a function are held by the ** arguments object ** it has a length property to tell how many arguments actually passed into body of a function. Note this is a property not a method.<br>

      Functions that take any numbers of arugments like console.log() have internal looping for them arguments.<br>

      Math: There is only one Math object, and it works like a group of math related functionalities.<br>

      global object: the global scope like where global variables live is represented by one objecrt called window, anything global variables are properties of this object.<br>

      <p><strong>Methods of this chapter:</strong></p>

      <strong>indexOf()</strong>, <strong>lastIndexOf()</strong> both of these methods take optional second arguments as the index where they start to search for the frist arguement index.<br>
      <strong>slice()</strong>: If we supply 2 arugments this mehtod uses them as starting index and ending index of search and return items in between them, the start index is inclusive, end index is exlusive. If we supply only 1 arugment it will return all items after this arguement index. <strong>similar method for Strings as well.</strong><br>
      <strong>concat()</strong>: concatinate two arrays.<br>
      <strong>trim()</strong>: removes whitespace from start and end of the string. (String method)<br>
      <strong>charAt()</strong>: takes index and returns the char at the index.<br>

      <strong>Math.random()</strong>: returns only number from 0 to 1(exclusive).<br>

      <h3>Higher-Order Functions(Chapter 5)</h3>
      <p>
        <strong>Array.forEach()</strong>: To apply same function to each elements inside an array<br>
        <strong>Array.filter()</strong>: To apply same function to each elements inside an array and return a new array containing the filtered elements, working much like Ruby method select in Array class<br>
        <strong>Array.map()</strong>: The same like the Ruby map<br>
        <strong>Array.reduce()</strong>: Combining all elements inside an array to a single value, i like how it works like selecting method to get the highest value and smallest value of an array.<br>
        NOTE: forEach. filter, map, reduce all take optional second arguement which indicates the index number of element we are iterating. We can use underscord to block one of those argument to ignor it like in<br> Ruby<pre><code>array.map {|_, arg2| block }</code></pre> JS <pre><code>myArray.map (function(_, index) { block });</code></pre>
      </p>

      <h3>The Secret Life of Objects(Chapter 6)</h3>
      <p>
        <strong>this</strong>: refers to the object a properties is called on, if you just simply print this with a console.log it will print a {}<br>
        <strong>prototype</strong>: In addition to objects properties, almost of the object also have prototype and prototype's prototype, when a property is get called, the properties get searched, then prototype get searched. If there is one, then it gets excuted. <pre><code>console.log(Object.getPrototypeOf({}) == Object.prototype); // true </code></pre>This kind of designe is much similar to Ruby as OOP language, that in Ruby there is an Object class as base class of all classes. In JavaScript we have this Object.prototype as a base prototype that has some methods shared by all the objects. Like

<pre><code>Object.toString()
Object.getPrototypeOf(target)
Object.create(aObjectName) //This method create a new object with protoype of the argument object</code></pre>

        <strong>Constructors</strong>: Constructors work much like classes in Ruby. Define a constructor like defininig a funciton, using function keyword and following by {} like defining obejct. Use new keyword in front of the constructor method name to create a new object of this constructor. When interpreter sees new keyword it will treat this as a constructor call. An obejct created this by a constructor function is a instace of this constructor. Prototypes get shared with this instance. Constructors prototype: Every constructor has a property named prototype, it is a plain obejct that derived from Object.prototype. Every instance of this constructor will have this property as its prototype. So when we just do aConstructor.prototype.methodName = function () {}; we define a new property(or method for this constructor's prototype property) then all the instance fo this constructor will have this method. Note that constructors are functions. So the actual prototype of a constructor is Function.prototype. All those properties defined in a prototype are allowed to be overriden by the instances of this constructor.<br>
        There is a very interesting thing about the properties we define inside an object:
        <pre><code>
          Object.prototype.nonsense = "Hi";
          for (var item in anObject) {
            console.log(item);
          }
        </code></pre>
        This interstingly prints everything with nonsense as well. Becasue in JavaScript properties are either <strong>enumerable</strong> or <strong>nonenumerble</strong>. Enumerable properties are the properties we simply assign with equal sign = the non enumerables are the standard properties in prototypes. It is possible to define nonenumerable properties using <code>Object.defineProperty()</code> which give the right to controll what properties we are creating.<br>
        <code>object.hasOwnProperty("propertyName")</code>: This method is more useful than <code>in</code> because this tells us if a object actually has a property called this name or not.<br>
        properties checking snippit:
        <pre><code>
          for (var name in map) {
            if (map.hasOwnProperty(name)) {
              // ... this is an own property
            }
          }
        </code></pre>
        Better more, in JavaScript we can also create an object with no prototype. Because this prototype is like Modules in Ruby, a packeage of properties and sometimes you just don't need it, not even the Object.prototype. In this case we can use <code>Object.create(null);</code> then we assign this value to a variable, this new object does not have anything.<br>
        <strong>Object.keys(objectName)</strong>: Returns an array contains all properties of argument object.<br>
        <strong>Inheritance</strong>: simply using <code>new Object = Object.create(object.prototype);</code> to have the newObject carries the same prototype as the argument object has.

      </p>

      <h3>Project: Electronic Life(Chapter 7)</h3>
      <p>
        <strong>Note</strong> that when we have a function embeded in another function, the inner function does not get to share this with outter function. The words from book is<strong> " In fact, when a function isn’t called as a method, this will refer to the global object."</strong> To do so we need to assign the outter this to a variable so we can use it any where. Or JS provides a method bind method to be applyed on the end of inner function, with argument (this) inside parenthises. This method bind the outer this to the inner function so you can use this to refer outter function scope and use it inside inner function. Good thing about arrays higher order funcitons like forEach, map, etc. They optionaly take second argument, we can pass this to the second argument of those function calls, without having to use bind(this) method.<br>

        <strong>Array.indexOf()</strong>: returns -1 when it is not included in this array.<br>

        <strong>Function.call(this, arg1, arg2)</strong>: This method chains the constructor function and initializes the constructor functions initialization.<br>
      </p>

      <h3>Bugs And Error Handling(Chapter 8)</h3>
      <p>
        When using constructor function without having <strong>new</strong> in front of it, JS will still create stuff, but this time, properties created by <strong>this</strong> going to be a global property(variable), because this then refers to <strong>window</strong> top level object.<br>
        By writing 'use strict' on the top of a program, we ask console to run our code in a strict model, so it will give us errors.<br>
        <strong>Exceptions</strong>: Code that runs into a problem to raise(throw) an exception, which is a value in JavaScript. Raising an exception is like calling a powerful return which returns all the way to the caller where the stack starts off. This way of return also called <strong>unwinding the stack</strong><br>
        Using <strong>catch</strong> to catch an exception and do something with it, then program will start running code from that point where exception was caught.<br>
        <strong>throw</strong> is used to raise an exception, follow throw is a <strong>new Error(message)</strong><br>
        <strong>try</strong> is where we run the code that we think the exception should appear<br>
        <strong>catch(error)</strong> follow right after <strong>try { }</strong> and pass the error object and do something inside the block { }<br>
        Error constructor create an object with a <strong>message</strong> property and it also gather info where the problem is returned, and save the info to <strong>stack</strong> property. Common JS error constructors all have <strong>name</strong> property which refers to the name of this constructor. We can return stack property for debugging<br>
        <strong>finally</strong> works like <strong>ensure</strong> claus in Ruby, which will excute its block no matter what.<br>
        In JS exception handeling recognize all errors as errors, which can be very confusing sometimes, if we want to specify error handling we can make our own exception constructor and inherite prototype from Erro constructor, and use if else claues in catch to catch our exception only.<br>
        creating assertions is helpful, it just simply blow up our program so we will fix problems.<br>
      </p>

      <h3>Regular Expressions(Chapter 9)</h3>
      <p>
        A regular expression is a type of object in JS<br>
        <strong>test()</strong>: method takes a string argument and being applyed on to a regular expression object. <pre><code>console.log(/\d{3}/.test("333")); // true</code></pre>
        <strong>exec()</strong>: this method sligly different, it returns null for unmatched, return an object with matched information. It also provides an index property tells us where in the string it was matched. String values has a method match( regx ) works the same way
        <strong>Date()</strong>: constructor function which takes nothing and returns a time object to indicates the time for now. <code>new Date()</code> , we can also pass numbers as arguments to parse the number to time object. <code>console.log(new Date(2012, 2, 10));</code>.<br>
        <strong>getTime()</strong>: works on Date object and returns a millisecond count fron 1970<br>
        <strong>getFullYear()</strong>: returns full year.<br>
        <strong>getMonth()</strong>:<br>
        <strong>getDate()</strong>:<br>
        <strong>getHours()</strong>:<br>
        <strong>getMinutes()</strong>:<br>
        <strong>getSeconds()</strong>:<br>
        <strong>replace()</strong>: String method to replace first match <code>'papa'.replace('p', 'd'); </code>first argument can be used as regular expression <code>'papa'.replace(/[p]/, 'd');</code> It is also possible to pass a funciton as second argument its return value will be inserted into string<br>
        <strong>RegExp()</strong>: constructor for regular expression. Take a string regular expression as first argument the second arg is flag argument, we can pass in things like i, g, etc<br>
        <strong>search()</strong>: takes regular expressions and return the matching index of a string or returning -1 when nothing found.
        <strong>lastIndex()</strong>: returns the last match index of a regualr expression

      </p>

      <h3>Modules(Chapter 10)</h3>
      <p>
        when making modules conventionaly we can excute an anonymous function which we can pass in an exported object and add properties inside calling function to that object instead having to return many function definitions.<br>
        Modules:
        <ul>
          <li>by wrapping all the scuttered code together and include them inside an object.(browser approach)</li>
          <li>by using require('fileName') and assign to a variable we get to use the moduel files after loading. This style is called CommonJS</li>
          <li>Another solution is to wrap the code that makes up your module in a function so that the module loader can first load its dependencies in the background and then call the function, initializing the module, when the dependencies have been loaded. This style is called AMD</li>
        </ul>
        <pre><code>
          define(["weekDay", "today"], function(weekDay, today) {
            console.log(weekDay.name(today.dayNumber()));
          });
        </code></pre>
        The modules that are loaded this way must themselves contain a call to define function like this:
        <pre><code>
          define([], function() {
            return {
              hello: function() {
                console.log('hello');
              },
              goodbye: function() {
                console.log('goodbye');
              }
            };
          });
        </code></pre>
        Unlike CommonJS, AMD takes a browser-first approach alongside asynchronous behavior to get the job done.<br>
        Overall: CommonJS Modules and revolves around a require function that fetches a module by name and returns its interface. The other is called AMD and uses a define function that takes an array of module names and a function and, after loading the modules, runs the function with their interfaces as arguments.<br>
        <strong>eval(stringObject)</strong> : takes a string of code and excutes it as JS code.<br>
        <strong>Function()</strong> : While eval is good but sometimes it breaks the scopes. We can use Function() constructor which takes 2 string arguments. First argument is comma seperated list of arugments, the second argument is a string of function body. like this:
        <pre><code>
          var myFunction = new Function('x, y', 'return x + y;');
          console.log(myFunction(5, 6));
          // 11
        </code></pre>
      </p>

      <h3>I did a little quizz and here is what i found as reflections of learning JS</h3>
      <ul>
        <li>JavaScript has the same data type for integer and float</li>
        <li>integer divided by 0 returns infinity</li>
        <li>when divide a integer by non-numeric object JS doesn't return error instead it returns NaN(Not a Number)</li>
        <li>NaN is not equal to another value, including itself</li>
        <li>typeof(NaN) is number.</li>
        <li>when define a variable with no value, it returns undefined because its value is undefined</li>
        <li>JS can concatenate number and string with + but it converts the number to string first then concat</li>
        <li>JS can do math with a string and a number, but it converts the string to number first then do math</li>
        <li>empty string considered falsey</li>
        <li>typeof an array returns 'object'</li>
        <li>arrays are false when compared with ===</li>
        <li>The falsey values are the empty string, 0, the keyword false, undefined, and null. In a boolean context, falsey values are treated as false (falsey values don't necessarily equal false).</li>
        <li>when define a variable inside a function(local scope) with no var keyword it is then a global variable and accessible anywhere.</li>
        <li>When this is invoked inside an open function not in a method, it refers to window object</li>
        <li>JS design quirk, inner function this points to the window global object, consider following code:
          <pre><code>
            var haha = {
              lala: function() {
                function dada() {
                  return this === window;
                }
                return dada();
              }
            }

            console.log(haha.lala());  // true
          </code></pre></li>
        <li>functions have name a property which returns a string of the name of this function. The name for anonymous function is ''</li>
        <li>arguments object is array like but it is not an arary, so can not use forEach such array methods</li>
        <li>apply vs. call: consider following code:
          <pre><code>
            var me = {
              name: 'Chunyu',
              country: 'China',
              age: 24
            }

            function intro(num1, num2, num3) {
              return 'hi, I'm ' + this.name + " from " + this.country + ' ' + (num1 + num2 + num3);
            }

            // calling apply
            console.log(intro.apply(me, [1, 2, 3]));
            // "hi, I'm Chunyu from China 6"

            // calling call
            console.log(intro.call(me, 1, 2, 3));
            // "hi, I'm Chunyu from China 6"
          </code></pre></li>
        <li>Object values are typically anonymous functions, but they can also be named functions. A named function works well to allow for recursion.</li>
        <li>functions are objects and can be assigned properties just like normal objects</li>
        <li>functions have length property to refer the length of params</li>
      </ul>



   </main>


 </div>
   <footer>
    <p>Contact me: <a href="mailto:ouchunyu@yahoo.com">ouchunyu@yahoo.com</a> </p>
   </footer>
</body>
</html>