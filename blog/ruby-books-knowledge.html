<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" type="text/css" href="../stylesheets/blog_template.css">
  <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">

  <title>Blog|Chunyu Ou</title>
  <style type="text/css">
    em {
      color: red;
      font-size: 1.5em;
      font-family: courier;
    }

    #bottom-nav a:hover {
      text-decoration: none;
    }

  </style>
</head>
<body>
 <div id="wrapper">
   <header>
    <div id="header-title">
      <a href="../index.html">Chunyu Ou</a>
    </div>
    <nav id="main-nav">
      <a href="../index.html">Home</a>
      <a href="../project.html">Project</a>
      <a href="../about.html">About</a>
    </nav>

    <div id="container">
      <ul>
        <li><a href="https://github.com/OUCHUNYU" target="_blank"><i class="fa fa-github fa-3x"></i></a></li>
        <li><a href="https://twitter.com/OUCHUNYU" target="_blank"><i class="fa fa-twitter fa-3x"></i>
        </a></li>
        <li><a href="https://www.facebook.com/chunyu.ou.52" target="_blank"><i class="fa fa-facebook-official fa-3x"></i></a></li>
      </ul>
    </div>
   </header>

   <main id="main-article">
    <p id="post-date">Created on: March 23, 2016</p>
    <hr>
    <p>
        <h2> RUBY PART 1 </h2>


<ul>

    File.unlink(file_name, ..)<br>
    This method deletes the files named arguments in parentheses and returns a integer indicates the numbers of arguments.<br>

    <p>——————————————————————————————————————————————————</p>
    Reassignment and replace method<br>
     a = ‘ruby’; b = a; a.replace(‘Jruby’); puts a # Jruby; puts b # Jruby<br>
    a = ‘ruby’; b = a ; a = ‘Jruby’; puts a # Jruby; puts b # ruby<br>

    <p>——————————————————————————————————————————————————</p>
    Something need to know about the class methods that inherited from supper class<br>
    Let say this method attire_accessor. It’s defined in Module class as a private instance method. And how we use this method commonly in some class we define, they act there like a class method without explicitly calling self. Which means that when they serve in a normal class definition attire_accessor works like a class method: self.attri_accessor. This is something to do with Ruby hierarchy. In Ruby any newly defined class is a instance of Class class, and Class class in a descendant of Module. This results in that a newly defined class is an instance of Module class, so if there is a instance method defined in Module class, and this newly defined class can use the Module’s instance method, because this newly defined class is an instance of Module. Interesting.<br>

    <p>——————————————————————————————————————————————————</p>
    Include vs. prepend<br>
    When using prepend to mix in a module to a class. It effects the method look up mechanism. The method lookup will search the mixing first then the containing class.<br>
    Include a mixing the method lookup will go for the containing class before the mixing module.<br>
    Best way to lookup is to use ancestor method, which will return the hierarchy in order.<br>

    <p>——————————————————————————————————————————————————</p>
    Module vs. Class<br>
    Differences:<br>
    Module is mixed in to classes, and especially it can be mixed in to many classes and Class can have only one super class. Module can not be instantiated but class can. All instance methods inside a mixed in Module are accessible by all the instance objects of that class.<br>

     Note the way to make all the instance methods of a module is to open class << self and include this module in there. Then you have all the instance methods for the Class as class methods.<br>

    When to use a class over a module?<br>
    In my opinion when you need a method bundle and also the ability to instantiate a new object.<br>


    When to use a module over a class?<br>
    When you have some helper methods that you possibly use over times thru the code and there is no need for generating new objects. There is a special way that we can nest a class inside a module. This is manly for the namespace purpose i think.<br>

    There is a very good example i think demonstrates when to use one over anther. If you look at the design of Ruby language, all newly created classes and modules or predefined classes and predefined modules are instances of Module and above that they are all part of Object class. So we can say pretty much every objects is a descendant of Object class. The fact that Object does not have as much methods predefined in it, BUT it includes the Kernel which is itself a module object, that has more than hundred of methods, and this how all the objects we created has that many methods. The point here is clear, the purpose of Object class is to have ability to instantiate new objects, and the method package is in Kernel module. That suites my opinion of when you should use a class and when you should use a module.<br>

    <p>——————————————————————————————————————————————————</p>
    Self of private instance methods<br>
    A private instance method can not have a explicit receiver. But every method call you need a object to do so. So the receiver object of a private instance method is self and this self is omitted because it can not be called explicitly as said before. Note this self has to be an instance of a class where the private instance method defined, so the only place you can place this method call is inside a duration of an instance execution.<br>
    However, there is one thing you need to know is, when you private a setter method, and you call it inside a duration of a instance, you call it without explicit having a receiver, Ruby interpreter will think this method call as a local variable assignment, which is not cool. In this case, Ruby allows you to explicitly call self.setter_method  = something<br>

    <p>——————————————————————————————————————————————————</p>
    Assigning exceptions to variables at runtime<br>
    Example:<br>
    rescue ArgumentError => e<br>
    Using => after Exception class name and assignment to a variable. The point of the assignment is mainly to use backtrace and message methods. As example above you can call e.backtrace to return an array of strings that contains all the info of call stack when exception raised. e.message returns the string you provided for that exception rescue if any there.<br>

    <p>——————————————————————————————————————————————————</p>
    ==, eql?, equal?<br>
    The first two are  same, the third one compares object ids.<br>

    <p>——————————————————————————————————————————————————</p>
    string[sub_string]<br>
    returns sub_string if found else nil<br>

    <p>——————————————————————————————————————————————————</p>
    Internally Ruby uses symbols to keep track of all the variables and methods and constants it defined. Symbol.all_symbols returns an array of all the symbols. more than 3000.<br>

    include?(a_symbol)  always returns true.!!<br>


    <p>——————————————————————————————————————————————————</p>
    By require ‘Date’<br>
         require ‘’Time<br>
    Ruby supply you a pretty good parser for date. Date.parse(’33/6/9’) returns 2033-06-09<br>

    <p>——————————————————————————————————————————————————</p>
    RECAP of collections<br>

    Array:<br>
    Array.new(arr_size, arr_items)  # Array.new(3, ‘apple’)  -> [‘apple’, ‘apple’, ‘apple’]<br>

    Array.new(3) {block} This will set each element of the new array to the return value of the block.<br>

    arr[arr_index, length]  -> returns an array of items from the first argument to the length.<br>

    shift pop take argument of integer to pop or shift numbers of items.<br>

    [1, 2, 3] * ‘-‘  returns 1-2-3<br>

    [1, 2, 3, 2, 3, 1].uniq  returns [1, 2, 3]<br>

    arr.compact removes nils<br>

    arr.count(item) returns a number of occurrence of item in this arr<br>


    Hash:<br>
    hash.values_at(key_1, key_2) returns [value_1, value_2]<br>

    Note: h = Hash.new(0) when require non-existing key like h[whatever] it returns 0. But it does not have a key hash[whatever] that has value 0 yet. If you want to have such function you need to supply a block like this h = Hash.new {|hash, key| hash[key] = 0}. Now if you don’t set a value to a key using h[whatever], it will be auto set to 0 and stored in this hash. It is not common to do so, because usually if you got return from a result of some sort, at least commonly you will have a nil or something, a nil works fine with hash.<br>

    update is destructive merge is nondestructive, merge! is however.<br>

    hash.invert flip the keys and values. Note if a value has dup the dups will be discard.<br>

    <p>——————————————————————————————————————————————————</p>
    Enumerable<br>
    array.group_by {|arg| block } returns a hash each key is the return value of the block and the value to that key is an array of item from receiver that return the same result.<br>

     array.partition {|arg| block} returns an array of two array, the first array has all the elements that block returned true. Second array has all the items that block return false.<br>

    each_line    # When reading a file like object line by line, this method does not care what your object is, It cares if the object has occurrence of a value that is equal to a global variable $/. if you reset this variable the method will return based on what you changed. The default value of $/ is new line character.<br>

    If you want to sort a collection for your class, define a <=> and inside definition of this method tell it what to compare, then you can call sort on the collection to get a sorted list of thing.<br>

    When we see a enumerator, it is as much like an array or a hash. If you call each_char on a string object, we get an enumerator object, it is like an array , we can then map it or select or whatever method of Enumerable, we can call it.<br>

    Lazy method of Enumerator, When dealing with a collection of infinite objects, we can first call lazy on the collection as we turn this infinite collection to a finite collection, then chain it with an enumerable method to do the iteration, or you can extract some of the objects, however you want. But the point here is, when dealing with an infinite collection, an iterator method looks at the whole collection, but it never ends, so we don’t get any result.<br>

    <p>——————————————————————————————————————————————————</p>
    Ruby IO<br>

    STDIN default to keyboard input, STDERR, STDOUT default to terminal output.<br>

    Most of these instance methods are up to use after you have created a IO object with class method new followed by the file name, if it does not exist will raise an error.<br>

    read method reads the entire file as a single string.<br>

    readlines returns an array of strings.<br>

    readline and gets read next line of a file, rewind goes back to the 0line of a file. When run out of line deadline method will raise an error where gets won’t.<br>

    pos(position) returns the position index of where in the file the pointer is currently pointing, where it has left of reading.<br>
    You can also set instance_name.pos = num equal to a desired position number, and it will move the pointer to the corresponding location in a file. This will return a string that starts from the pointer location we set, till the next newline char File object encounters.<br>

    File class methods:<br>

    File.exits?(a file name/ or directory name)<br>

    File.unlink -> delete<br>

    File.read, File.readlnes do the same thing as its instance methods.<br>

    MOST IMPORTANTLY <File objects are enumerables which we can manipulate as other objects. We can iterate through LINE BY LINE but not object by object unless you saved in that file objects or something. So with this in mind we should not create an Array or something to hold the read file and iterate through it, instead directly iterate the file. so we don’t take extra memory space><br>

    FileTest.readable?; FileTest.writable?; FileTest.executable? permission checking for a file.<br>

    <p>——————————————————————————————————————————————————</p>
    Dir<br>

    Instance methods:  (To use these method of course Dir.new(dir_name) goes first.)<br>

    entries which works like glob but i will return an array of all files names including hidden files and files starts with . and parent directory files.<br>
    So most of cases glob will be a better choice, both instance and class methods are available.<br>

    path, returns the original directory path of this particular Dir instance.<br>

    glob has pattern match feature which works mostly likes shells. Passing a flag as second argument in parentheses, like File::FNM_CASEFOLD means case insensitive. NOTE glob returns full file paths instead of only file names<br>
<br>
    class methods:<br>
<br>
    Dir.mkdir(path/name)<br>
    Dir.chdir(path/name) Navigate to this directory<br>
    Dir.rmdir(path/name) remove<br>

    <p>——————————————————————————————————————————————————</p>
    Lambda<br>
    When calling a lambda object and supply wrong number of arguments is not acceptable, it raises and error. IN which proc object will not, if you supply more than it needs it discards the remainders.<br>

    instance_eval  {change the self to the receiver object}<br>
    we can use this method to execute the instance variable in initialize method that are intended not to be accessible. Call this method on any instance of that class and access that instance variable in { }<br>
    class_eval i see most of use is to def instance methods with receiver as class object, instance method definition being put inside { }<br>

    <p>——————————————————————————————————————————————————</p>
    & operator<br>
    Range.instance_methods(false) & Enumerable.instance_methods(false)<br>
    this performs an array of method names that they both have but Range overrides.<br>
</ul>

    </p>



   </main>


  <div id="bottom-nav">
    <ul>
      <li><button type="button" class="btn btn-default"><a href="">Last Post</a></button></li>
      <li><button id="right" type="button" class="btn btn-default"><a href="">Next Post</a></button></li>
    </ul>
  </div>
 </div>
   <footer>
    <p>Contact me: <a href="mailto:ouchunyu@yahoo.com">ouchunyu@yahoo.com</a> </p>
   </footer>
</body>
</html>